# Longest Palindromic Substring



## 1. 动态规划


这道题其实用DP做思路是最清晰的，不过时间复杂度与空间复杂度相对而言都有着不小的提升空间。

官方Solution里提到它给出的DP算法是可以优化空间复杂度的，这里简单说一下怎么对空间复杂度进行优化。官方Solution里给出的DP解法需要维护一个二维矩阵，那么空间复杂度即为O(n^2)，递推式如下

P(i,i)=true

P(i,j)=(P(i+1,j-1)  and  S_i==S_j)   	当 j>i+1 时

P(i,j)=(S_i==S_{i+1})      										当j=i+1 时

可以看出，P(i,j) 要么可以直接算出，要么依赖于P(i+1,j-1)

对于这种情况的动态规划，可以进行状态矩阵的压缩。

对于每个j，我们只需要二维状态矩阵的第j-1列即可求出第j列。也即是说，如果对j进行遍历，对于特定的j只需要前一列（也即第j-1列）的信息。因此，在任意时刻我们只需要存储上一列的信息就可以完成求解，在求解完新的一列后，把存储的信息更新为新求解出的这一列即可。因此，空间复杂度降为了O(n)。

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        int n = s.size(), left = 0, len = 1;
        bool dp[n];
        for(int j = 0; j < n; ++j){
            dp[j]=true;
            for(int i = 0; i < j; ++i){
                dp[i] = dp[i+1] && (s[i] == s[j]);
                if(dp[i] && len < j - i + 1){
                    len = j - i + 1;
                    left = i;
                }
            }
        }
        return s.substr(left, len);
    }
};
```



## 2.Manacher算法

Manacher算法在<https://en.wikipedia.org/wiki/Longest_palindromic_substring>或[https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2](https://zh.wikipedia.org/wiki/最长回文子串)中有详细介绍，这里只简单讲解一下思路和复杂度证明。



Manacher算法先在字符串的每两个字符中间（包括两端）插入一个“隔位符”（需要是字符串中未出现过的字符），得到一个新的待处理的字符串（记为s)。这种预处理保证了所有可能的回文串都是奇数长度的（偶数长度的回文串最中间的两个相邻字符必须相同，而任何两个相邻的字符中必有且仅有一个”隔位符“，不可能相同）

奇数长度的回文串有这样的特点：一定以某个字符为中心，关于这个字符对称的两个字符相同。因此，我们遍历字符串所有的字符，将它们分别作为中心，同时向左右延伸，**在下文，我们只显式说明向右的延伸，向左的延伸不显式地指出，但其延伸过程是与向右的延伸对称同步的**，找出最长的回文串，记录这些回文串的长度，最后找出最长的即可。

接下来是Manacher算法的重点。

我们需要维护一个叫做maxRight的变量，用于记录在遍历s的每个字符并以其为中心寻找回文串的过程中，所有已找到的回文串的最右端字符的下标中的最大值。通俗点讲，就是算法执行至今寻找回文串的过程中延伸到过的最靠右（靠近字符串尾端）的位置。

我们还需要维护一个maxIndex变量，用于记录maxRight所对应的那个回文串（记为strmax）的中心的位置。

当我们遍历到第i个字符时，显然i大于maxIndex。

如果此时的i小于maxRight，我们找到i关于maxIndex的对称点j

* 如果以第j个字符为中心的回文串（记为strj）是strmax的子串，由于回文串的对称性，以第i个字符为中心的回文串（记为stri）的长度与strj相等，stri也是strmax的子串，stri的最右端仍在strmax内，无需更新maxRight
* 如果strj不是strmax的子串，也即是说strj的左端在strmax之外。此时我们只能保证以第i个字符为中心，向右延伸，到达maxRight时停止所得到的字符串是回文串。但继续延伸还可能得到更长的回文串，maxRight将被更新。好处是我们可以直接以s.substr(2*i-maxRight ,maxRight+1)为基础向外延伸，strmax内的部分是不需要延伸的。

如果i大于maxRight，那么我们无法节省任何操作。只能从第i个字符开始向右延伸寻求最长的回文串。maxRight必然被更新。

以上便是Manacher算法的基本思路。



接下来证明Manacher算法的时间复杂度是O(n)的。

Manacher算法的主要开销便是延伸操作（每次向左右各延伸一格），算法事先的预处理和其他操作显然是O(n)的。而我们可以给出延伸操作次数的一个简单的上界。

上文对于以i为中心的延伸细分出了三种情况。第一种情况不需要延伸操作，第二种情况从maxRight开始向右延伸，第三种情况从i开始向右延伸。虽然三种情况各自出现的次数是无法确定的，但第二、三种情况中，每次延伸的次数总是不大于maxRight的增长量。而在整个算法过程中，maxRight的总增长量就是字符串的长度，因此延伸操作的次数也是O(n)的。









